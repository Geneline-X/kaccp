generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Session {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  userId       String
  sessionToken String   @unique
  user         User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expiresAt])
}

model Notification {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  readAt          DateTime?
  userId          String
  type            String
  title           String
  body            String?
  transcriptionId String?
  transcription   Transcription? @relation(fields: [transcriptionId], references: [id])
  user            User           @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model User {
  id                 String              @id @default(cuid())
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  email              String              @unique
  passwordHash       String
  isActive           Boolean             @default(true)
  lastLoginAt        DateTime?
  displayName        String?
  role               UserRole            @default(TRANSCRIBER)
  qualityScore       Float               @default(0)
  totalEarningsCents Int                 @default(0)
  phone              String?             @unique
  avatarUrl          String?
  bio                String?
  country            String?
  showOnLeaderboard  Boolean             @default(true)
  uploads            AudioSource[]       @relation("UserUploads")
  assignments        ChunkAssignment[]
  notifications      Notification[]
  payments           Payment[]
  reviews            Review[]
  sessions           Session[]
  transcriptions     Transcription[]
  walletTxns         WalletTransaction[]
}

model AudioSource {
  id                   String       @id @default(cuid())
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  title                String
  description          String?
  sourceRef            String?
  originalUri          String
  totalDurationSeconds Int          @default(0)
  status               AudioStatus  @default(UPLOADED)
  statusMessage        String?
  uploadedById         String?
  chunks               AudioChunk[]
  uploadedBy           User?        @relation("UserUploads", fields: [uploadedById], references: [id])
}

model AudioChunk {
  id                      String            @id @default(cuid())
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  sourceId                String
  index                   Int
  startSec                Int
  endSec                  Int
  durationSec             Int
  storageUri              String
  status                  ChunkStatus       @default(AVAILABLE)
  approvedTranscriptionId String?           @unique
  approvedTranscription   Transcription?    @relation("ApprovedTranscription", fields: [approvedTranscriptionId], references: [id])
  source                  AudioSource       @relation(fields: [sourceId], references: [id])
  assignments             ChunkAssignment[]
  transcriptions          Transcription[]

  reportedBroken Boolean   @default(false)
  reportedBy     String?
  reportedAt     DateTime?
  
  @@unique([sourceId, index])
  @@index([status, createdAt])

}

model ChunkAssignment {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  chunkId     String
  userId      String
  expiresAt   DateTime?
  releasedAt  DateTime?
  chunk       AudioChunk      @relation(fields: [chunkId], references: [id])
  user        User            @relation(fields: [userId], references: [id])
  submissions Transcription[]

  @@index([userId, chunkId])
  @@index([userId, releasedAt])
  @@index([expiresAt])
}

model Transcription {
  id               String          @id @default(cuid())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  assignmentId     String
  chunkId          String
  userId           String
  text             String
  language         String          @default("en")
  guidanceScore    Float?
  notes            String?
  submittedAt      DateTime?
  aiModel          String?
  aiScore          Float?
  aiSuggestedText  String?
  approvedForChunk AudioChunk?     @relation("ApprovedTranscription")
  notifications    Notification[]
  review           Review?
  assignment       ChunkAssignment @relation(fields: [assignmentId], references: [id])
  chunk            AudioChunk      @relation(fields: [chunkId], references: [id])
  user             User            @relation(fields: [userId], references: [id])

  @@index([submittedAt])
}

model Review {
  id                  String         @id @default(cuid())
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  transcriptionId     String         @unique
  reviewerId          String
  decision            ReviewDecision
  comments            String?
  approvedDurationSec Int?
  useAiSuggestion     Boolean        @default(false)
  reviewer            User           @relation(fields: [reviewerId], references: [id])
  transcription       Transcription  @relation(fields: [transcriptionId], references: [id])
}

model PaymentRatePlan {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  name               String   @unique
  ratePerMinuteCents Int
  currency           Currency @default(SLE)
  active             Boolean  @default(true)
}

model Payment {
  id                 String              @id @default(cuid())
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  userId             String
  amountCents        Int
  currency           Currency            @default(SLE)
  status             PaymentStatus       @default(PENDING)
  reference          String?
  notes              String?
  user               User                @relation(fields: [userId], references: [id])
  walletTransactions WalletTransaction[]
}

model WalletTransaction {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  userId           String
  deltaCents       Int
  description      String?
  relatedPaymentId String?
  relatedPayment   Payment? @relation(fields: [relatedPaymentId], references: [id])
  user             User     @relation(fields: [userId], references: [id])
}

model ExportRecord {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  chunkId     String   @unique
  audioPath   String
  englishText String
  durationSec Int
  sourceId    String
}

enum UserRole {
  ADMIN
  TRANSCRIBER
}

enum AudioStatus {
  UPLOADED
  PROCESSING
  READY
  TRANSCRIBING
  COMPLETED
  FAILED
}

enum ChunkStatus {
  AVAILABLE
  ASSIGNED
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  PROCESSING
  FAILED
}

enum ReviewDecision {
  APPROVED
  REJECTED
  EDIT_REQUESTED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

enum Currency {
  USD
  SLE
}
